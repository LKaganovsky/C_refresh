In general, network programming is done using a client-server paradigm, where a server exists at a fixed address
and serves information to client devices. A client requests to establish a connection, and then both client and
server can freely send and receive data, until one side terminates the connection (manually or via timeout). 

Traditionally, a client-server model implies specific behaviours for both parties--in web browsing for example, 
a client (a web browser) establishes a connection to a server at a fixed address, and sends a request which 
includes which web page/resource it wants to download. The server then checks that it knows what to do with the
incoming request, and responds appropriately--in most cases, this simply involves sending the requested web page.

Comparatively, the peer-to-peer paradigm features many hosts ("peers") all performing the same responsibilities,
exchanging data in more or less even quantities between peers. However, even in the P2P model, the underlying 
sockets using TCP and UDP are not created equal--in each connection, one peer is listening, and the other 
connecting. In BitTorrent, a popular P2P protocol for file sharing, a central server known as a tracker stores a 
list of IP addresses of peers who have agreed to behave like a server and listen for new connections. When a peer
wants to join the swarm, it requests a list of peers from the central server, and attempts to establish a 
connection to peers on that list while also listening for new connections from other peers. A P2P protocol does 
not as much replace a client-server model as much as it makes all clients behave as if they were both a server
and a client.

The File Transfer Protocol (FTP) works similarly. Initially, the FTP server listens for connections until the FTP
client connects. After the initial connection, the FTP client can request files from the server, which will 
attempt to establish a new connection to the client for transfer. For this reason, the FTP client first 
establishes a connection as a TCP client, but later accepts connections like a TCP server.

Network programs can often be described as one of four types: TCP server, TCP client, UDP server, UDP client.

TCP PROGRAM FLOW
TCP Client must know server's address--this is often obtained from the user via entering a URL into a browser or by 
clicking a link. 

TCP Client uses getaddrinfo() to resolve the address of the server into a struct addrinfo structure.

TCP Client creates a socket with socket().

TCP Client establishes a new TCP connection by calling connect().

TCP Client uses send() and recv() to exchange data with TCP Server.

-----

TCP Server calls getaddrinfo() to create an struct addrinfo structure with its own credentials. (?)

TCP Server calls socket() to create a socket.

TCP Server calls bind() to bind the socket to the listening IP address and port.

TCP Server calls listen() and sets socket into a state where it listens for incoming connections.

TCP Server calls accept() to preemptively accept incoming client connections to the server.

TCP Server call to accept() returns a new socket when a new client connection has been established.

TCP Server calls send() and recv() on new socket to exchange data with TCP Client.

Note that there is significant variation in how this exchange can play out due to the asynchronous nature
of networking. There is no rule as to which side calls send() or recv() first, or how many times. Both 
sides should call send() as soon as the connection is established.

UDP PROGRAM FLOW
UDP Client must know the server's address.

UDP Client uses getaddrinfo() to resolve the address of the server into a struct addrinfo structure.

UDP Client creates a socket with socket().

UDP Client uses sendto() to send the first packet.

UDP Client uses sendto() and recvfrom() on its socket to send and receive additional packets.

-----

UDP Server calls getaddrinfo() to create a struct addrinfo structure with its own credentials. (?)

UDP Server calls socket() to create a socket.

UDP Server calls bind() to bind the socket to the listening IP address and port.

UDP Server calls recvfrom(), blocks until it receives data from UDP Client.

UDP Server unblocks after receiving data from a UDP Client, can freely sendto() and recvfrom().

Note that the client must send the first packet in a UDP program.

NEW FUNCTIONS
getaddrinfo()   Allocates and initializes a linked list of addrinfo structures, based on the 
                arguments passed in (host and service/port number). Protocol independent.

socket()        Creates a socket and returns a file descriptor for that socket.

bind()          A socket created by socket() exists in a name space (address family) but does
                not have an address assigned to it. The bind() function assigns the sockaddr
                structure argument to the socket file descriptor argument. Traditionally 
                known as "assigning a name to a socket."

listen()        Marks the socket referred to by the file descriptor argument as a passive 
                socket, to listen for incoming connections it will respond to with accept().

accept()        Used with connction-based socket types. Extracts the first connection request
                on the queue of pending connections for the listening socket (specified by the
                file descriptor), creates a new socket, and returns the new socket's file 
                descriptor. New socket is not in listening state. The original socket is not
                affected by this call.

getnameinfo()   Inverse of getaddrinfo(). Converts a socket address to a corresponding host 
                and service (port number). Protocol independent.

send()          Sends data with a socket.

recv()          Receives data with a socket.

sendto()        Sends data from a socket without a bound remote address.

recvfrom()      Receives data from a socket without a bound remote address.

close()         Closes a socket. Winsock equivalent is closesocket().

shutdown()      Closes the full-duplex connection on the specified socket gracefully.

select()        Allows for a program to wait for one or more sockets to become "ready" for
                some class of I/O operation.

setsockopt()    Change options on the specified socket.

fcntl()         Change additional options on the specified socket. Winsock equivalent is ioctlsocket().

